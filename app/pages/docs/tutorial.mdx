---
title: Tutorial
sidebar_label: Tutorial
---

In questo tutorial, ti guideremo attraverso la creazione di una semplice
applicazione di votazione.

Supponiamo che tu abbia gi√† [installato Blitz] (./get-started). Puoi
verificare se Blitz sia installato e quale versione hai eseguendo il
seguente comando nel tuo terminale:

```sh
blitz -v
```

Se Blitz √® installato, dovresti vedere la versione della tua
installazione. Se non lo √®, avrai un errore del tipo ‚Äúcommand not found:
blitz‚Äù.

## Creare una nuova applicazione {#creare-una-nuova-applicazione}

Dalla riga di comando, esegui un `cd` all'interno della directory in cui
vorresti creare la tua applicazione e quindi lancia il seguente comando:

```sh
blitz new my-blitz-app
```

Blitz creer√† una directory `my-blitz-app` nella tua directory attuale. Ti
verr√† chiesto di selezionare una libreria per il form. Per questo
tutorial, scegliere l'opzione di default `React Final Form`.

Diamo un'occhiata a quello che `blitz new` ha creato:

```
my-blitz-app
‚îú‚îÄ‚îÄ app/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mutations/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ changePassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logout.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgot-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reset-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validations.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ core/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Form.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ LabeledTextField.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hooks/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useCurrentUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ layouts/
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ Layout.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 404.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _app.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _document.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.test.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ users/
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ queries/
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ getCurrentUser.ts
‚îú‚îÄ‚îÄ db/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ seeds.ts
‚îú‚îÄ‚îÄ integrations/
‚îú‚îÄ‚îÄ mailers/
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ forgotPasswordMailer.ts
‚îú‚îÄ‚îÄ public/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ favicon.ico*
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ logo.png
‚îú‚îÄ‚îÄ test/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils.tsx
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ babel.config.js
‚îú‚îÄ‚îÄ blitz.config.js
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ types.d.ts
‚îú‚îÄ‚îÄ types.ts
‚îî‚îÄ‚îÄ yarn.lock
```

Questi file sono:

- La directory `app/` contiene la maggior parte del progetto. Qui √® dove
  verr√† inserita ogni pagina o route per le API.

- La directory `app/pages/` √® quella primaria per le pagine. Se hai
  utilizzato Next.js noterai immediatamente la differenza. In Blitz √®
  possibile avere pi√π directory `pages` su cui poi verr√† fatto un merge in
  fase di build.

- La directory `app/core/` √® il luogo principale in cui inserire
  component, hook, ecc. che verranno utilizzati all'interno
  dell'applicazione.

- `db/` √® dove vengono inserite le configurazioni per il database. Se stai
  realizzando model o migration, qui √® dove devono essere inseriti.

- `public/` √® dove andranno inseriti tutti gli asset statici. Se hai
  immagini, file o video che andranno utilizzati all'interno
  dell'applicazione, il posto giusto dove inserirli √® questo.

- `.babelrc.js`, `.env`, etc. ("dotfiles") sono file di configurazione per
  i vari tool JavaScript.

- `blitz.config.js` serve per una personalizzazione avanzata di Blitz. Ha
  lo stesso formato di `next.config.js`.

- `tsconfig.json` √® la nostra configurazione consigliata per TypeScript.

## Il server di sviluppo {#il-server-di-sviluppo}

Assicurati di essere all'interno della directory `my-blitz-app`, se gi√†
non lo sei, e lancia il seguente comando:

```sh
blitz dev
```

Vedrai il seguente output sulla command line:

```sh
‚úî Compiled
Loaded env from /private/tmp/my-blitz-app/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /my-blitz-app/babel.config.js
event - compiled successfully
```

Ora che il server √® attivo, visita [localhost:3000](http://localhost:3000)
tramite web browser. Vedrai una pagina di benvenuto, con il logo Blitz.
Funziona!

## Registrati come utente {#registrati-come-utente}

Le app Blitz vengono create con le procedure di registrazione e login
utente gi√† impostate! Quindi proviamo. Clicca sul pulsante **Sign Up**.
Inserisci una qualsiasi email e password e clicca **Create Account**.
Verrai reindirizzato alla homepage dove potrai vedere `id` e `ruolo` del
tuo utente.

Se vuoi, puoi anche provare a effettuare il logout e poi riconnetterti
nuovamente. Oppure clicca su **Forgot your password?** sulla pagina di
login per verificare il flusso.

## Crea la tua prima pagina {#crea-la-tua-prima-pagina}

Andiamo quindi a creare la tua prima pagina.

Apri il file `app/pages/index.tsx` e sostituisci il contenuto del
component `Home` con questo:

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Hello, world!</h1>

      <Suspense fallback="Loading...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Una volta salvate le modifiche dovresti vedere la pagina aggiornata sul
browser. Puoi personalizzare questa parte come preferisci. Quando sei
pronto, procedi col prossimo paragrafo.

## Setup del database {#setup-del-database}

Buone notizie, un database SQLite √® gi√† pronto per te! Puoi lanciare
`blitz prisma studio` nel terminale per aprire un'interfaccia web dove
puoi visualizzare i dati nel tuo database.

Nota che una volta avviato il tuo primo vero progetto, magari preferirai
utilizzare un database pi√π scalabile come PostgreSQL, per evitare il
problema di dover cambiare database in corso d'opera. Per maggiori
informazioni, consulta l'[overview sul database](database-overview). Per
il momento, proseguiremo col database SQLite di default.

## Scaffolding per i model {#scaffolding-per-i-model}

Blitz fornisce un pratico comando CLI chiamato
[`generate`](./cli-generate) per lo scaffolding del nostro boilerplate.
Useremo `generate` per creare due model: `Question` e `Choice`. Una
`Question` conterr√† il testo della domanda e un elenco di scelte. Una
`Choice` conterr√† il testo della scelta, un conteggio dei voti e una
domanda associata. Blitz generer√† automaticamente un ID, un timestamp di
creazione e un timestamp dell'ultimo aggiornamento per entrambi i model.

#### Per prima cosa, creeremo tutto ci√≤ che riguarda il model `Question`:

```sh
blitz generate all question text:string
```

Quando richiesto, premere **Enter** per eseguire il comando
`prisma migrate` che aggiorner√† lo schema del database con il nuovo model.
Chieder√† un nome, quindi digita qualcosa come "add question".

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

‚úî Model for 'question' created in schema.prisma:

> model Question {
>   id        Int      @default(autoincrement()) @id
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   text      String
> }

? Run 'prisma migrate dev' to update your database? (Y/n) ‚Ä∫ true
```

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Name of migration ‚Ä¶ add question
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210217035805_add_question/
    ‚îî‚îÄ migration.sql

‚úî Generated Prisma Client (2.17.0) to ./node_modules/@prisma/client in 103ms

Everything is now in sync.
```

Il comando `generate` con type `all` crea un model e i file per le query,
mutation e pagine. Consulta la pagina [Blitz generate](./cli-generate) per
la lista delle opzioni disponibili.

#### Poi creeremo il model `Choice` con le corrispondenti query e mutation.

Questa volta passeremo un type `resource` dal momento che non abbiamo
bisogno di creare pagine per il model `Choice`:

```sh
blitz generate resource choice text votes:int:default=0 belongsTo:question
```

Se si verifica un errore, lancia il comando `blitz prisma format`

Nota che questo non richiede una migration del database perch√© non abbiamo
ancora aggiunto il campo `Choice` al model `Question`. Quindi scegliamo
`false` quando ci viene chiesto di eseguire la migration:

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

‚úî Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   text       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) ‚Ä∫ false
```

#### Infine andiamo ad aggiornare il model `Question` per metterlo in relazione con `Choice`.

Apri il file `db/schema.prisma` e aggiungi `choices Choice[]` al model
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  text      String
+ choices   Choice[]
}
```

Ora possiamo eseguire la migration per aggiornare il nostro database:

```sh
blitz prisma migrate dev
```

Di nuovo, inserisci un nome per la migration, come "add choice":

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Name of migration ‚Ä¶ add choice
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210412175528_add_choice/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.
```

Adesso il nostro database √® pronto ed √® stato anche generato un client
Prisma. Proseguiamo col giocare col client Prisma!

## Giocando col database client Prisma {#giocando-col-database-client-prisma}

Ora, saltiamo nella shell interattiva di Blitz e giochiamo con il database
client Prisma che Blitz offre. Per avviare la console Blitz, usa questo
comando:

```sh
blitz console
```

Una volta all'interno della console, esplora il database client:

```sh
# No questions are in the system yet.
‚ö° > await db.question.findMany()
[]

# Create a new Question:
‚ö° > let q = await db.question.create({data: {text: "What's new?"}})
undefined

# See the entire object:
‚ö° > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "What's new?"
}

# Or, access individual values on the object:
‚ö° > q.text
"What's new?"

# Change values by using the update function:
‚ö° > q = await db.question.update({where: {id: 1}, data: {text: "What's up?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "What's up?"
}

# db.question.findMany() now displays all the questions in the database:
‚ö° > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "What's up?"
  }
]
```

## Aggiornare il codice generato per gli attributi del model {#aggiornare-il-codice-generato-per-gli-attributi-del-model}

<!-- prettier-ignore-start -->
:::info
Prima di eseguire nuovamente l'app, √® necessario personalizzare parte del codice generato. In futuro, queste correzioni non saranno necessarie - ma per ora dobbiamo aggirare un paio di problemi in sospeso.
:::
<!-- prettier-ignore-end -->

Il contenuto della pagina generata attualmente non utilizza gli effettivi
attributi del model definiti durante la generazione. Sar√† presto cos√¨, ma
nel frattempo andiamo a correggere le pagine generate.

### Pagine per le domande {#pagine-per-le-domande}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

Apriamo il file `app/pages/questions/index.tsx`. √à possibile notare che √®
stato generato un component `QuestionsList`:

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions,
    {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button
        disabled={isPreviousData || !hasMore}
        onClick={goToNextPage}
      >
        Next
      </button>
    </div>
  )
}
```

Questo per√≤ non funzioner√†! Ricorda che il modello `Question` che abbiamo
creato sopra non ha alcun campo `name`. Per risolvere questo problema,
sostituisci `question.name` con `question.text`:

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions, {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={isPreviousData || !hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

Successivamente, applica una correzione simile a
`app/questions/components/QuestionForm.tsx`. Nella parte di submission del
form, sostituisci il `LabeledTextField` `name` con `"text"`

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Text" placeholder="Text" />
    </Form>
  )
}
```

### Mutation `createQuestion` {#mutation-create-question}

In `app/questions/mutations/createQuestion.ts`, abbiamo bisogno di
aggiornare lo zod validation schema `CreateQuestion` per usare `text`
invece di `name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### Mutation `updateQuestion` {#update-question-mutation}

In `app/questions/mutations/updateQuestion.ts`, abbiamo bisogno di
aggiornare lo zod validation schema `UpdateQuestion` per usare `text`
invece di `name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### Mutation `deleteQuestion` {#mutation-delete-question}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma non supporta ancore le "cascading delete". Nell'ambito di questo
tutorial, questo implica che non vengono cancellati i dati di `Choice`
quando viene cancellata una `Question`. Abbiamo bisogno di aumentare
temporaneamente la mutation `deleteQuestion` in modo da effettuare
l'operazione manualmente. Apri il file
`app/questions/mutations/deleteQuestion.ts` in un editor di testo e
aggiungi il seguente contenuto all'inizio del corpo della funzione:

```ts
await db.choice.deleteMany({where: {questionId: id}})
```

Il risultato finale sar√† qualcosa di questo tipo:

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

Questa mutation eliminer√† ora le scelte associate ad una domanda prima di
eliminare la domanda stessa.

#### Ora prova a creare, aggiornare ed eliminare le domande

Ottimo! Ora assicurati che la tua app sia in esecuzione. In caso
contrario, esegui `blitz dev` nel tuo terminale e collegati a
`localhost:3000/questions`. Prova a creare domande, modificarle ed
eliminarle.

## Aggiungere delle scelte al form della domanda {#aggiungere-delle-scelte-al-form-della-domanda}

Fin qui ottimo lavoro! Il prossimo passo che faremo √® aggiungere delle
scelte al form della domanda. Apri il file
`app/questions/components/QuestionForm.tsx` nell'editor.

Aggiungi altri tre component `<LabeledTextField>` come scelte.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Text" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Choice 1" />
+     <LabeledTextField name="choices.1.text" label="Choice 2" />
+     <LabeledTextField name="choices.2.text" label="Choice 3" />
    </Form>
  )
}
```

Poi apri il file `app/pages/questions/new.tsx` e imposta la variabile
`initialValues` come segue:

```diff
      <QuestionForm
        submitText="Create Question"
-       // initialValues={{ }}
+       initialValues={{choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

Adesso apri il file `app/questions/mutations/createQuestion.ts` e aggiorna
lo schema zod in modo tale che i dati della scelta siano accettati nella
mutation. √à anche necessario aggiornare la chiamata `db.question.create`
in modo tale che le scelte vengano anche create.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
    text: z.string(),
+   choices: z.array(z.object({text: z.string()})),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

#### Provalo

Adesso puoi collegarti su `localhost:3000/questions/new` e creare una
nuova domanda completa di scelte!

## Elencare le scelte {#elencare-le-scelte}

Prendiamoci un attimo di respiro. Torna su `localhost:3000/questions` e
guarda tutte le domande che hai creato. Che ne dici di elencare anche qui
le scelte di queste domande? Per prima cosa, dobbiamo personalizzare le
query delle domande. In Prisma, √® necessario comunicare manualmente al
client che si desidera eseguire una query per le relazioni nested.
Modifica i file `getQuestion.ts` e `getQuestions.ts` in questo modo:

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // This accepts type of undefined, but is required at runtime
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Adesso riprendi sull'editor la pagina principale delle domande
(`app/pages/questions/index.tsx`), in modo da poter elencare la lista
delle choice per ogni domanda. Aggiungi questo codice sotto `Link` nel
`QuestionsList`:

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Adesso controlla la pagina `/questions` sul browser. **Magia!**

## Lasciamo che le persone votino sulle domande! {#lasciamo-che-le-persone-votino-sulle-domande}

Apriamo `app/pages/questions/[questionId].tsx` nell'editor. Innanzitutto,
miglioreremo leggermente questa pagina.

1. Sostituisci `<h1>Question {question.id}</h1>` con
   `<h1>{question.text}</h1>`.

2. Cancella l'elemento `pre`, e copia nella lista della scelte quello che
   abbiamo scritto prima:

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votes
    </li>
  ))}
</ul>
```

Se ritorni sul browser, la pagina dovrebbe essere qualcosa di simile!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Ora √® il momento di aggiungere la votazione!

Per prima cosa dobbiamo aprire il file
`app/choices/mutations/updateChoice.ts`, aggiornare lo schema zod e
aggiungere un incremento di voto.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Adesso ritorna sul file `app/pages/questions/[questionId].tsx` e applica
le seguenti modifiche:

Nel tuo `li`, aggiungi un `button` come questo:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votes
  <button>Vote</button>
</li>
```

Quindi, importa la mutation `updateChoice` che abbiamo aggiornato e crea
una funzione `handleVote` nella nostra pagina:

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

Poi √® necessario aggiornare la chiamata `useQuery` per restituire la
function `refetch` che utilizziamo all'interno di `handleVote`:

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Infine, diremo al nostro nuovo `button` di richiamare quella function!

```tsx
<button onClick={() => handleVote(choice.id)}>Vote</button>
```

La versione finale del component `Question` dovrebbe essere qualcosa di
simile:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({id})
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votes
              <button onClick={() => handleVote(choice.id)}>Vote</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Edit</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("This will be deleted")) {
              await deleteQuestionMutation({id: question.id})
              router.push("/questions")
            }
          }}
          style={{marginLeft: "0.5rem"}}
        >
          Delete
        </button>
      </div>
    </>
  )
}
```

## Infine, consentiamo di modificare le scelte per una domanda esistente {#modificare-le-scelte-per-una-domanda}

Se clicchi sul pulsante **Edit** su una delle domande esistenti, vedrai
che utilizza lo stesso form rispetto alla creazione di una domande. Quindi
quella parte √® gi√† fatta! Dobbiamo solo aggiornare la mutation.

Apri il file `app/questions/mutations/updateQuestion.ts` ed effettua le
seguenti modifiche:

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}).nonstrict(),
+   ),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
+           // Appears to be a prisma bug,
+           // because `|| 0` shouldn't be needed
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
√® un'operazione speciale che significa: "Se questo elemento esiste,
aggiornalo. Altrimenti crealo". Questo √® perfetto per questo caso perch√©
non abbiamo richiesto all'utente di aggiungere tre scelte durante la
creazione della domanda. Quindi, se in seguito l'utente aggiunge un'altra
scelta modificando la domanda, questa verr√† creata qui.

## Conclusione {#conclusione}

ü•≥ Congratulazioni! Hai creato la tua app Blitz! Divertiti a giocarci o
condividila con i tuoi amici. Ora che hai finito questo tutorial, perch√©
non provare a migliorare ulteriormente la tua app di voto? Potresti
provare a:

- Aggiungere degli stili (Suggerimento, prova `blitz install tailwind` o
  `blitz install chakra-ui`)
- Mostrare qualche altra statistica sui voti
- Effettuare un deploy live su [Render](./deploy-render) o
  [Vercel](./deploy-vercel)

Se vuoi condividere il tuo progetto con la community mondiale di Blitz,
non c'√® modo migliore per farlo che su Discord.

Visita [discord.blitzjs.com](https://discord.blitzjs.com). Quindi, carica
il link sul canale **#built-with-blitz** per condividerlo con tutti!
