---
title: Tutorial
sidebar_label: Tutorial
---

In questo tutorial, ti guideremo attraverso la creazione di una semplice
applicazione di votazione.

Supponiamo che tu abbia giÃ  [installato Blitz] (./ get-started). Puoi
verificare se Blitz sia installato e quale versione hai eseguendo il
seguente comando nel tuo terminale:

```sh
blitz -v
```

Se Blitz Ã¨ installato, dovresti vedere la versione della tua
installazione. Se non lo Ã¨, avrai un errore del tipo â€œcommand not found:
blitzâ€.

## Creare una nuova applicazione {#creating-a-new-app}

Dalla riga di comando, esegui un `cd` all'interno della directory in cui
vorresti creare la tua applicazione e quindi lancia il seguente comando:

```sh
blitz new my-blitz-app
```

Blitz creerÃ  una directory `my-blitz-app` nella tua directory attuale. Ti
verrÃ  chiesto di selezionare una libreria per il form. Per questo
tutorial, scegliere l'opzione di default `React Final Form`.

Diamo un'occhiata a quello che `blitz new` ha creato:

```
my-blitz-app
â”œâ”€â”€ app/
â”‚Â Â  â”œâ”€â”€ api/
â”‚Â Â  â”œâ”€â”€ auth/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LoginForm.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SignupForm.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mutations/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ changePassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgotPassword.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgotPassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ logout.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resetPassword.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resetPassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ signup.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pages/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgot-password.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ reset-password.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ signup.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ validations.ts
â”‚Â Â  â”œâ”€â”€ core/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Form.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ LabeledTextField.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useCurrentUser.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ layouts/
â”‚Â Â  â”‚Â Â      â””â”€â”€ Layout.tsx
â”‚Â Â  â”œâ”€â”€ pages/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 404.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _app.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _document.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.test.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â””â”€â”€ users/
â”‚Â Â      â””â”€â”€ queries/
â”‚Â Â          â””â”€â”€ getCurrentUser.ts
â”œâ”€â”€ db/
â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ schema.prisma
â”‚Â Â  â””â”€â”€ seeds.ts
â”œâ”€â”€ integrations/
â”œâ”€â”€ mailers/
â”‚Â Â  â””â”€â”€ forgotPasswordMailer.ts
â”œâ”€â”€ public/
â”‚Â Â  â”œâ”€â”€ favicon.ico*
â”‚Â Â  â””â”€â”€ logo.png
â”œâ”€â”€ test/
â”‚Â Â  â”œâ”€â”€ setup.ts
â”‚Â Â  â””â”€â”€ utils.tsx
â”œâ”€â”€ README.md
â”œâ”€â”€ babel.config.js
â”œâ”€â”€ blitz.config.js
â”œâ”€â”€ jest.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ types.d.ts
â”œâ”€â”€ types.ts
â””â”€â”€ yarn.lock
```

Questi file sono:

- La directory `app/` contiene la maggior parte del progetto. Qui Ã¨ dove
  verrÃ  inserita ogni pagina o rotta per le API.

- La directory `app/pages/` Ã¨ quella primaria per le pagine. Se hai
  utilizzato Next.js noterai immediatamente la differenza. In Blitz Ã¨
  possibile avere piÃ¹ directory `pages` su cui poi verrÃ  fatto un merge in
  fase di build.

- La directory `app/core/` Ã¨ il luogo principale in cui inserire
  component, hook, ecc. che verranno utilizzati all'interno
  dell'applicazione.

- `db/` Ã¨ dove vengono inserite le configurazioni per il database. Se stai
  realizzando model o migration, qui Ã¨ dove devono essere inseriti.

- `public/` Ã¨ dove andranno inseriti tutti gli asset statici. Se hai
  immagini, file o video che andranno utilizzati all'interno
  dell'applicazione, il posto giusto dove inserirli Ã¨ questo.

- `.babelrc.js`, `.env`, etc. ("dotfiles") sono file di configurazione per
  i vari tool Javascript.

- `blitz.config.js` serve per una personalizzazione avanzata di Blitz. Ha
  lo stesso formato di `next.config.js`.

- `tsconfig.json` Ã¨ la nostra configurazione consigliata per TypeScript.

## Il server di sviluppo {#the-development-server}

Assicurati di essere all'interno della directory `my-blitz-app` folder, se
giÃ  non lo sei, e lancia il seguente comando:

```sh
blitz dev
```

Vedrai il seguent output sulla command line:

```sh
âœ” Compiled
Loaded env from /private/tmp/my-blitz-app/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /my-blitz-app/babel.config.js
event - compiled successfully
```

Ora che il server Ã¨ attivo, apri il link
[localhost:3000](http://localhost:3000) tramite web browser. Vedrai una
pagina di benvenuto, con il logo Blitz. Funziona!

## Registrati come utente {#sign-up-as-a-user}

Le app Blitz vengono create con le procedure di registrazione e login
utente giÃ  impostate! Quindi proviamo. Clicca sul pulsante **Sign Up**.
Inserisci una qualsiasi email e password e clicca **Create Account**.
Verrai reindirizzato alla homepage dove potrai vedere `id` e `ruolo` del
tuo utente.

Se vuoi, puoi anche provare a effettuare il logout e poi riconnetterti
nuovamente. Oppure clicca su **Forgot your password?** sulla pagina di
login per verificare il flusso.

## Crea la tua prima pagina {#write-your-first-page}

Andiamo quindi a creare la tua prima pagina.

Apri il file `app/pages/index.tsx` e sostituisci il contenuto del
component `Home` con questo:

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Hello, world!</h1>

      <Suspense fallback="Loading...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Una volta salvate lo modifiche dovresti vedere la pagina aggiornata sul
browser. Puoi personalizzare questa parte come preferisci. Quando sei
pronto, procedi col prossimo paragrafo.

## Setup del database {#database-setup}

Buone notizie, un database SQLite Ã¨ giÃ  pronto per te! Puoi lanciare
`blitz prisma studio` nel terminale per aprire un'interfaccia web dove
puoi visualizzare i dati nel tuo database.

Nota che una volta avviato il tuo primo vero progetto, magari preferirai
utilizzare un database piÃ¹ scalabile come PostgreSQL, per evitare il
problema di dover cambiare database in corso d'opera. Per maggiori
informazioni, consulta l'[overview sul database](database-overview). Per
il momento, proseguiremo col database SQLite di default.

## Scaffolding del codice per i model {#scaffolding-code-for-our-models}

Blitz fornisce un pratico comando CLI chiamato
[`generate`](./cli-generate) per lo scaffolding del codice del nostro
boilerplate. Useremo `generate` per creare due model: `Question` e
`Choice`. Una `Question` conterrÃ  il testo della domanda e un elenco di
scelte. Una `Choice` conterrÃ  il testo della scelta, un conteggio dei voti
e una domanda associata. Blitz genererÃ  automaticamente un ID, un
timestamp di creazione e un timestamp dell'ultimo aggiornamento per
entrambi i model.

#### Per prima cosa, creeremo tutto ciÃ² che riguarda il model `Question`:

```sh
blitz generate all question text:string
```

Quando richiesto, premere **Enter** per eseguire il comando
`prisma migrate` che aggiornerÃ  lo schema del database con il nuovo model.
ChiederÃ  un nome, quindi digita qualcosa come "add question".

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

âœ” Model for 'question' created in schema.prisma:

> model Question {
>   id        Int      @default(autoincrement()) @id
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   text      String
> }

? Run 'prisma migrate dev' to update your database? (Y/n) â€º true
```

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

âœ” Name of migration â€¦ add question
The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20210217035805_add_question/
    â””â”€ migration.sql

âœ” Generated Prisma Client (2.17.0) to ./node_modules/@prisma/client in 103ms

Everything is now in sync.
```

Il comando `generate` con type `all` crea un model e i file per le query,
mutation e pagine. Consulta la pagina [Blitz generate](./cli-generate) per
la lista delle opzioni disponibili.

#### Poi creeremo il model `Choice` con le corrispondenti query e mutation.

Questa volta passeremo un type `resource` dal momento che non abbiamo
bisogno di creare pagine per il model `Choice`:

```sh
blitz generate resource choice text votes:int:default=0 belongsTo:question
```

Se si verifica un errore, lancia il comando `blitz prisma format`

Di nuovo, premi **Enter** quando viene richiesto di lanciare la migration
e inserisci un nome per quest'ultima.

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

âœ” Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   text       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) â€º true
```

#### Infine andiamo ad aggiornare il model `Question` per metterlo in relazione con `Choice`.

Apri il file `db/schema.prisma` e aggiungi `choices Choice[]` al model
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  text      String
+ choices   Choice[]
}
```

Quindi lancia il comando `blitz prisma generate` per aggiornare il client
prisma su questa modifica nello schema. Questa operazione non richiede una
migration del database, perchÃ¨ non sono stati effettivamente aggiunti
campi nel database per il model `Question`.

## Giocando col database client Prisma {#playing-with-the-prisma-database-client}

Ora, saltiamo nella shell interattiva di Blitz e giochiamo con il database
client Prisma che offre. Per avviare la console Blitz, usa questo comando:

```sh
blitz console
```

Una volta all'interno della console, esplora il database client:

```sh
# No questions are in the system yet.
âš¡ > await db.question.findMany()
[]

# Create a new Question:
âš¡ > let q = await db.question.create({data: {text: "What's new?"}})
undefined

# See the entire object:
âš¡ > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "What's new?"
}

# Or, access individual values on the object:
âš¡ > q.text
"What's new?"

# Change values by using the update function:
âš¡ > q = await db.question.update({where: {id: 1}, data: {text: "What's up?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "What's up?"
}

# db.question.findMany() now displays all the questions in the database:
âš¡ > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "What's up?"
  }
]
```

## Update generated code for our model attributes {#update-generated-code-for-our-model-attributes}

<!-- prettier-ignore-start -->
:::info
Before running the app again, we need to customize some of the
code that has been generated. Ultimately, these fixes will not be needed -
but for now, we need to work around a couple outstanding issues.
:::
<!-- prettier-ignore-end -->

The generated page content does not currently use the actual model
attributes you defined during generation. It will soon, but in the
meantime, let's fix the generated pages.

### Question pages {#question-pages}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

Jump over to `app/pages/questions/index.tsx`. Notice that a
`QuestionsList` component has been generated for you:

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}] = usePaginatedQuery(getQuestions, {
    orderBy: {id: "asc"},
    skip: ITEMS_PER_PAGE * page,
    take: ITEMS_PER_PAGE,
  })

  const goToPreviousPage = () => router.push({query: {page: page - 1}})
  const goToNextPage = () => router.push({query: {page: page + 1}})

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={!hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

This wonâ€™t work though! Remember that the `Question` model we created
above doesnâ€™t have any `name` field. To fix this, replace `question.name`
with `question.text`:

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}] = usePaginatedQuery(getQuestions, {
    orderBy: {id: "asc"},
    skip: ITEMS_PER_PAGE * page,
    take: ITEMS_PER_PAGE,
  })

  const goToPreviousPage = () => router.push({query: {page: page - 1}})
  const goToNextPage = () => router.push({query: {page: page + 1}})

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={!hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

Next, letâ€™s apply a similar fix to
`app/questions/components/QuestionForm.tsx`. In the form submission,
replace the `LabeledTextField` `name` to be `"text"`

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Text" placeholder="Text" />
    </Form>
  )
}
```

### `createQuestion` mutation {#create-question-mutation}

In `app/questions/mutations/createQuestion.ts`, we need to update the
`CreateQuestion` zod validation schema to use `text` instead of `name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `updateQuestion` mutation {#update-question-mutation}

In `app/questions/mutations/updateQuestion.ts`, we need to update the
`UpdateQuestion` zod validation schema to use `text` instead of `name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
  .nonstrict()
// ...
```

### `deleteQuestion` mutation {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma does not yet support "cascading deletes". In the context of this
tutorial, that means it does not currently delete the `Choice` data when
deleting a `Question`. We need to temporarily augment the generated
`deleteQuestion` mutation in order to do this manually. Open up
`app/questions/mutations/deleteQuestion.ts` in your text editor and add
the following to the top of the function body:

```ts
await db.choice.deleteMany({where: {questionId: id}})
```

The end result should be as such:

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

This mutation will now delete the choices associated with the question
prior to deleting the question itself.

#### Now try creating, updating, and deleting questions

Great! Now make sure your app is running. If it isnâ€™t, run `blitz dev` in
your terminal, and visit `localhost:3000/questions`. Try creating
questions, editing, and deleting them.

## Adding choices to the question form {#adding-choices-to-the-question-form}

Youâ€™re doing great so far! The next thing weâ€™ll do is add choices to our
question form. Open `app/questions/components/QuestionForm.tsx` in your
editor.

Add three more `<LabeledTextField>` components as choices.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Text" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Choice 1" />
+     <LabeledTextField name="choices.1.text" label="Choice 2" />
+     <LabeledTextField name="choices.2.text" label="Choice 3" />
    </Form>
  )
}
```

Next open `app/pages/questions/new.tsx` and set `initialValues` to be as
follows:

```diff
      <QuestionForm
        submitText="Create Question"
-       // initialValues={{ }}
+       initialValues={{choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

Then open `app/questions/mutations/createQuestion.ts` and update the zod
schema so that the choice data is accepted in the mutation. And we also
need to update the `db.question.create` call so that the choices will also
be created.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
    text: z.string(),
+   choices: z.array(z.object({text: z.string()})),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

#### Try it out

Now you can go to `localhost:3000/questions/new` and create a new question
with choices!

## Listing choices {#listing-choices}

Time for a breather. Go back to `localhost:3000/questions` in your browser
and look at all the questions youâ€˜ve created. How about we list these
questionsâ€™ choices here too? First, we need to customize the question
queries. In Prisma, you need to manually let the client know that you want
to query for nested relations. Change your `getQuestion.ts` and
`getQuestions.ts` files to look like this:

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // This accepts type of undefined, but is required at runtime
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Now hop back to our main questions page
(`app/pages/questions/index.tsx`)in your editor, and we can list the
choices of each question. And add this code beneath the `Link` in our
`QuestionsList`:

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Now check `/questions` in the browser. **Magic!**

## Letâ€™s let people vote on these questions! {#let-people-vote-on-questions}

Open `app/pages/questions/[questionId].tsx` in your editor. First, weâ€™re
going to improve this page somewhat.

1. Replace `<h1>Question {question.id}</h1>` with
   `<h1>{question.text}</h1>`.

2. Delete the `pre` element, and copy in our choices list which we wrote
   before:

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votes
    </li>
  ))}
</ul>
```

If you go back to your browser, your page should now look something like
this!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Now itâ€™s time to add voting!

First we need to open `app/choices/mutations/updateChoice.ts`, update the
zod schema, and add add a vote increment.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Now go back to `app/pages/questions/[questionId].tsx` and make the
following changes:

In our `li`, add a `button` like so:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votes
  <button>Vote</button>
</li>
```

Then, import the `updateChoice` mutation we updated and create a
`handleVote` function in our page:

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

And then we need to update the question `useQuery` call to return the
`refetch` function which we use inside `handleVote`:

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finally, weâ€™ll tell our new `button` to call that function!

```tsx
<button onClick={() => handleVote(choice.id)}>Vote</button>
```

The final `Question` component should now look like this:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({id})
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votes
              <button onClick={() => handleVote(choice.id)}>Vote</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Edit</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("This will be deleted")) {
              await deleteQuestionMutation({id: question.id})
              router.push("/questions")
            }
          }}
          style={{marginLeft: "0.5rem"}}
        >
          Delete
        </button>
      </div>
    </>
  )
}
```

## Lastly, let's allow editing choices for an existing question {#edit-choices-for-question}

If you click the **Edit** button on one of your existing questions, you'll
see it uses the same form as creating questions. So that part is already
done! We only need to update our mutation.

Open `app/questions/mutations/updateQuestion.ts` and make the following
changes:

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}).nonstrict(),
+   ),
  })
  .nonstrict()

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
+           // Appears to be a prisma bug,
+           // because `|| 0` shouldn't be needed
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
is a special operation that means, "If this item exists, update it. Else
create it". This is perfect for this case because we didn't require the
user to add three choices when creating the question. So if later the user
adds another choice by editing the question, then it'll be created here.

## Conclusion {#conclusion}

ðŸ¥³ Congrats! You created your very own Blitz app! Have fun playing around
with it, or sharing it with your friends. Now that youâ€™ve finished this
tutorial, why not try making your voting app even better? You could try:

- Adding styling (Hint, try `blitz install tailwind` or
  `blitz install chakra-ui`)
- Showing some more statistics about votes
- Deploying live on [Render](./deploy-render) or [Vercel](./deploy-vercel)

If you want to share your project with the world wide Blitz community
there is no better place to do that than on Discord.

Visit [discord.blitzjs.com](https://discord.blitzjs.com). Then, post the
link to the **#built-with-blitz** channel to share it with everyone!
